# Core format { #core-format }

## General { #fileFormat-General }

A SARIF log file shall contain the results of a one or more static analysis runs.
The runs need not be produced by the same static analysis tool.

A SARIF log file shall conform to the requirements of the JSON format.
The top-level value in the log file shall conform to the JSON object grammar;
that is, it shall consist of a comma-separated sequence of name/value pairs, enclosed in curly brackets,
as described in the JSON specification.
We refer to the object represented by this top-level value as the `sarifLog` object (&sect;[#sarifLog]).

Every JSON property name in the SARIF format shall be a camelCase name.
This includes the names of properties defined in property bags such as `result.properties` (&sect;[#result-properties]).

~ IsoNote
A single run of a static analysis tool that supports the SARIF format produces a SARIF log file
containing the results of that one run.
Other programs, such as build systems or result management systems, can consolidate the contents
of multiple single-run log files into a single SARIF log file that contains the results from all of those runs.
This allows the aggregated results to be conveniently stored in a file or transported over a network.
~

## URI-valued properties

Certain properties in this specification specify the URI of a file.
The value of every such property, if present, shall be a valid URI.

If the URI refers to a file stored in a version control system (VCS),
the value shall preserve relevant details that permit the target file to be retrieved from the VCS.
If the URI refers to a file stored on a physical file system, it may be specified as a relative URI
that omits root information details
(such as hard drive letter and an arbitrarily named root directory associated with a source code enlistment).

~ IsoNote
An absolute URI may contain information that represents unwanted information disclosure,
particularly in cases where a tool is analyzing files stored on a physical file system.
For example, a file path might contain the account name of a developer.
~

## Tag set properties

Certain properties in this specification are defined to be "tag sets".
A tag set is a JSON array containing zero or more arbitrary strings;
no element of the array shall be a number, an array, or an object.
No two of the strings shall be the same.
Two strings shall be considered the same if they consist of the same
sequence of Unicode code points.

## Property bag properties

Certain properties in this specification are defined to be "property bags".
A property bag is a JSON object.
The names of the properties within this JSON object shall be camelCase strings.
The values of the properties shall be arbitrary strings; they shall not be numbers, arrays, or sub-objects.

## Date/time properties { #fileFormat-dateTime }

Certain properties in this specification specify a date and time.
The value of every such property, if present, shall be a string in the following format,
which is compatible with [ISO-8601:2004](http://www.iso.org/iso/catalogue_detail?csnumber=40874)

```
<dateTime>: <date>T<time>Z

<date>:     YYYY-MM-DD

<time>:     hh:mm:ss[.sss]
```

Here `YYYY` is a 4-digit year,
`MM` is a 2-digit month from 01 to 12,
`DD` is a 2-digit day from 01 to 31,
`T` is a literal character "T" separating the date from the time,
`hh` is a 2-digit hours from 00 to 23,
`mm` is a 2-digit minutes from 00 to 59,
`ss` is a 2-digit seconds from 00 to 59,
`[.sss]` is an optional 3-digit number of milliseconds from 000 to 999, and
`Z` is a literal character "Z" specifying UTC time.

~ IsoExample

```
2016-02-08T16:08:25Z
2016-02-08T16:08:25.943Z
```
~

## `sarifLog` object { #sarifLog }

### General { #sarifLog-General }

An `sarifLog` object specifies the version of the file format and contains the output from one or more runs.

~ IsoExample

```
{
    "version" : "0.1",  # see \(&sect;[#sarifLog-version]\)
    "runLogs" :         # see \(&sect;[#sarifLog-runLogs]\)
    [
        {
            ...         # a runLog object (see \(&sect;[#runLog]\))
        },
        ...
        {
            ...         # another runLog object
        }
    ]
}
```
~

### `version` property { #sarifLog-version }

A `sarifLog` object shall contain a property named `version` whose value is the string `"1.0.0-beta.1"`.

Although the order in which the name/value pairs appear in a JSON object value is not semantically significant,
the `version` property should appear first. 
~ IsoNote
This will make it easier for parsers to handle multiple versions of the SARIF format,
if new versions are defined in the future.
~

~ IsoNote
The value of this property, in the version of SARIF described by
this document and in all future versions of the SARIF standard, will be in the format specified by Semantic
Versioning 2.0.0
~

### `runLogs` property { #sarifLog-runLogs }

An `sarifLog` object shall contain a property named `runLogs` whose value is an array
of one or more runLog objects (&sect;[#runLog]).

## `runLog` object { #runLog }

### General { #runLog-General }

A `runLog` object describes a single run of a static analysis tool,
and contains the output of that run.

~ IsoExample

```
{
    "toolInfo":    # see \(&sect;[#runLog-toolInfo]\)
    {
        ...        # a toolInfo object (see \(&sect;[#toolInfo]\))
    },
    "runInfo":     # see \(&sect;[#runLog-runInfo]\)
    {
        ...        # a runInfo object (see \(&sect;[#runInfo]\))
    },
    "results":      # see \(&sect;[#runLog-results]\)
    [
        {
            ...    # a result object (see \(&sect;[#result]\))
        },
        ...
        {
            ...    # another result object
        }
    ]
}
```
~

### `toolInfo` property { #runLog-toolInfo }

A `runLog` object shall contain a property named `toolInfo` whose value is a `toolInfo` object (&sect;[#toolInfo]).

### `runInfo` property { #runLog-runInfo }

A `runLog` object may contain a property named `runInfo` whose value is a `runInfo` object (&sect;[#runInfo]).

### `results` property { #runLog-results }

A `runLog` object shall contain a property named `results` whose value is an array containing zero or more `result` objects (&sect;[#result]),
each of which represents a single result produced in the course of a run.

The `results` array shall be empty if the run that produced the `runLog` object did not produce any results.

## `toolInfo` object { #toolInfo }

### General { #toolInfo-General }

A `toolInfo` object contains information describing the static analysis tool that was run.

~ IsoNote
If another tool post-processes the log file (for example, by removing certain results,
or by adding information that was not known to the static analysis tool),
the post-processing tool should not alter any part of the `toolInfo` object.
~

~ IsoExample

```
{
    "name": "CodeScanner",                                       # see \(&sect;[#toolInfo-name]\)
    "fullName": "CodeScanner 2.0, Developer Preview (en-US)",    # see \(&sect;[#toolInfo-fullName]\)
    "version": "2.0.0-beta",                                     # see \(&sect;[#toolInfo-version]\)
    "fileVersion": "2.0.1502.2"                                  # see \(&sect;[#toolInfo-fileVersion]\)
}
```
~

### `name` property { #toolInfo-name }

A `toolInfo` object shall contain a property named `name` whose value is a string containing the name of the tool that produced the log file.

~ IsoExample
`"CodeScanner"`
~

### `fullName` property { #toolInfo-fullName }

A `toolInfo` object may contain a property named `fullName` whose value is a string containing the name of the tool
along with its version and any other useful identifying information, such as its locale.

~ IsoExample
`"CodeScanner 2.0, Developer Preview (en-US)"`
~

### `version` property { #toolInfo-version }

A `toolInfo` object should contain a property named `version` whose value is a string containing the tool version.
If present, the string should be in the format specified by Semantic Versioning 2.0.0.

~ IsoNote
Semantic versions have the property of being sortable in chronological order of release.
~

~ IsoExample
`"1.0.0-beta"`
~

### `fileVersion` property { #toolInfo-fileVersion }

If the operating system on which the tool runs provides a value for the file version of the tool's primary executable file,
then the `toolInfo` object may contain a property named `fileVersion` whose value is
a string representation of that file version.
If the operating system does not provide such a value, the `fileVersion` property shall not be present.

~ IsoExample
On the Windows platform, this information is available in the `FILEVERSION` member of the `VERSIONINFO` structure.
~

## `runInfo` object { #runInfo }

### General { #runInfo-General }

A `runInfo` object describes the invocation of the static analysis tool that produced the results specified
in the containing `runLog` object (&sect;[#runLog]).

~ IsoNote
The information in the `runInfo` object makes it possible to precisely repeat a run of a static analysis tool,
and to verify that the results reported in the log file were generated by an appropriate invocation of the tool.
~

### `runStartTime` property { #runInfo-runStartTime }

A `runInfo` object may contain a property named `runStartTime` whose value is a string
specifying the date and time at which the run started.
The string shall be in the format specified by (&sect;[#fileFormat-dateTime]).

### `runEndTime` property { #runInfo-runEndTime }

A `runInfo` object may contain a property named `runEndTime` whose value is a string
specifying the date and time at which the run ended.
The string shall be in the format specified by (&sect;[#fileFormat-dateTime]).

### `invocationInfo` property { #runInfo-invocationInfo }

A `runInfo` object may contain a property named `invocationInfo` whose value is a string
containing the runtime parameters with which the tool was invoked.
For command line tools, this string may consist of the completely specified command line used to invoke the tool.

~ IsoExample
Suppose a tool is invoked with the command line

```
    C:\Tools\CodeScanner\CodeScanner.exe /input C:\Code\*.cc
```

Then the value of the `invocationInfo` property should be `"C:\Tools\CodeScanner\CodeScanner.exe /input C:\Code\*.cc"`. In 
circumstances where the fully qualified path to the tool provides undesirable information disclosure, this information
may be omitted, for example:

```
    /input C:\Code\*.cc
```
~

### `analysisTargets` property { #runInfo-analysisTargets }

A `runInfo` object may contain a property named `analysisTargets` whose value is an array,
each of whose elements is a `fileReference` object (&sect;[#fileReference])
representing the location of a single analysis target scanned during the run.
This array shall contain one entry for each analysis target that was scanned,
even if the analysis targets were not individually specified on the command line.

~ IsoNumberedNote { @IsoNumberedNote=1 }
The command line with which the tool was invoked might specify its input files
by means of a wild card such as *.cc, or it might specify them implicitly,
for example, by scanning the files in the current directory.
~

The `analysisTargets` array shall be empty if no analysis targets were scanned in the course of the run.

~ IsoNumberedNote
This could happen if the command line specified a wildcard such as *.cc for the input files,
and no files matched the wildcard.
~

~ IsoExample

```
[
    {
        "uri": "file:///C:/Code/a.cc",
        "hashes": [
            {
                "value": "b13ce2678a8807ba0765ab94a0ecd394f869bc81",
                "algorithm": "SHA-256"
            }
        ]
    },

    {
        "uri": "file:///C:/Code/b.cc",
        "hashes": [
            {
                "value": "ffc654abaa74903dae1d2ff532078ec0a9d5f674",
                "algorithm": "SHA-256"
            }
        ]
    }
] 
```
~

## `fileReference` object { #fileReference }

### General { #fileReference-General }

A `fileReference` object represents a single file.

### `uri` property { #fileReference-uri }

A `fileReference` object shall contain a property named `uri` whose value is a string that represents
the location of the file as a valid URI.

### `hashes` property { #fileReference-hashes }

A `fileReference` object may contain a property named `hashes` whose value is an array of `hash` objects (&sect;[#hash]),
each of which specifies a hashed value for the file specified by the `uri` property (&sect;[#fileReference-uri]),
along with the name of the algorithm used to compute the hash.

If present, the array specified by `hashes` shall not be empty.

~ IsoNote
A hash value for an analysis target can be useful when a log file is processed by a result management system.
The value may be used as a key when persisting results in a database.
This allows a build system to use cached results, rather than repeating the analysis, when a target has not changed.
A file hash may also be useful for validating results in a policy compliance system,
allowing an auditor to validate that rerunning analysis against a target that hashes to a specific value reproduces the provided results.

The `fileReference` object defines an array of hash values, rather than a single hash value,
to allow a log file to be consumed by multiple tool chains that might expect hash values produced by differing algorithms.
Compliance systems, for example, will favor the use of secure hash algorithms (such as SHA-256)
that minimize the possibility that two different targets will produce the same hash (at the expense of speed to produce the hash). 
In situations where compliance and security are not a concern, a system might prefer to use a fast hash algorithm (such as MD5 or SHA-1)
that occasionally produces hash collisions.

To populate the `hashes` property, an analysis tool must support the ability to produce hashes for its analysis targets.
Alternatively, the hashes could be added to the log file as a post-processing step.

To make the best use of such an analysis tool, a user (such as a build engineer) would determine what systems
in their build environment will consume the log file.
The user would then configure the tool to produce hashes using the algorithms required by those systems.
Analysis tools that are configurable to produce hashes with a variety of commonly used algorithms
will interoperate most easily with such systems.
~

### `tags` property { #fileReference-tags }

A `fileReference` object may contain a property named `tags`, whose value is a tag set.

### `properties` property { #fileReference-properties }

A `fileReference` object may contain a property named `properties`, whose value is property bag.
This allows tools to include information about the file that is not explicitly specified in the SARIF format.

## `hash` object { #hash }

### General { #hash-General }

A `hash` object represents a hash value of some file or collection of files, together with the algorithm used to compute the hash.

~ IsoExample

```
{
    "value":"b13ce2678a8807ba0765ab94a0ecd394f869bc81",   # see \(&sect;[#hash-value]\)
    "algorithm":"SHA-256"                                 # see \(&sect;[#hash-algorithm]\)
}
```
~

### `value` property { #hash-value }

A `hash` object shall contain a property named `value` whose value is the hash value of some file or collection of files,
computed by the algorithm named in the `algorithm` property (&sect;[#hash-algorithm]). 

### `algorithm` property { #hash-algorithm }

A `hash` object shall contain a property named `algorithm`, whose value is a string specifying the name
of the algorithm used to compute the hash value specified in the `value` property (&sect;[#hash-value]).
This shall be one of the following:

*	`BLAKE-256`
*	`BLAKE-512`
*	`ECOH`
*	`FSB`
*	`GOST`
*	`Groestl`
*	`HAS-160`
*	`HAVAL`
*	`JH`
*	`MD2`
*	`MD4`
*	`MD5`
*	`MD6`
*	`RadioGatun`
*	`RIPEMD`
*	`RIPEMD-128`
*	`RIPEMD-160`
*	`RIPEMD-320`
*	`SHA-1`
*	`SHA-224`
*	`SHA-256`
*	`SHA-384`
*	`SHA-512`
*	`SHA-3`
*	`Skein`
*	`Snefru`
*	`Spectral Hash`
*	`SWIFFT`
*	`Tiger`
*	`Whirlpool`

## `result` object { #result }

### General { #result-General }

A `result` object describes a single result produced by a static analysis tool.

### `ruleId` property { #result-ruleId }

A `result` object shall contain a property named `ruleId` whose value is a string containing
the stable, opaque identifier for the rule that was evaluated to produce the result.

~ IsoExample
`"CA2101"`
~

### `kind` property { #result-kind }

A `result` object may contain a property named `kind` whose value is one of a fixed set of strings
that specify the category of the result.

If present, the `kind` property shall have one of the following values, with the specified meanings:

* `pass`: The rule specified by the `ruleId` property (&sect;[#result-ruleId]) was evaluated, and no problem was found.

* `warning`: The rule specified by the `ruleId` property was evaluated, and a problem was found.

* `error`: The rule specified by the `ruleId` property was evaluated, and a serious problem was found.

* `notApplicable`: The rule specified by the `ruleId` property was not evaluated, because it does not apply to the
file specified by `analysisTarget` (&sect;[#location-analysisTarget]).

~ IsoExample
A binary checker might have a rule that applies to 32-bit binaries only.
Such a tool would produce a `notApplicable` result if it were run on a 64-bit binary.
~

* `configurationError`: The tool encountered a rule configuration error.

    The `ruleId` property for a `result` object whose `kind` property is `configurationError` should be
    set to a unique value, distinct from the id of all other rules known to that tool, which indicates that
    an error occurred while reading rule configuration information.

~ IsoNote
Many tools can be parameterized with information about which rules to run, and how they should be configured.
In some cases, if the configuration information is invalid, the tool can ignore the invalid information
and continue to run.
~

~ IsoExample
Suppose a tool is invoked with a configuration file which specifies that the tool should disable rule X.
If there is no such rule as rule X, then the tool should report a `configurationError`. The tool might
continue to run, reporting results for the rules that are correctly configured.
~

* `internalError`: The tool encountered an internal error that prevented it from performing a complete analysis.

    If the error occurred in the course of evaluating a specific rule, the `ruleId` property should either specify that rule,
    or it should specify a unique value, distinct from the id of all other rules known to that tool, which indicates that
    an error occurred during rule evaluation.

    If the error did not occur in the course of evaluating a specific rule, the `ruleId` property should be set to a unique value,
    distinct from the id of all other rules known to that tool, which indicates that an internal tool error occurred.

~ IsoNote
Depending on the nature of the error, the tool might or might not be able to continue running.
In all cases, the presence of a `result` object whose `kind` property is set to `internalError` indicates
that the run failed, because it could could not successfully run all specified rules on all specified
analysis targets.

If a tool encounters an error in the course of evaluating a rule, the tool might report the error, disable the rule,
and continue to execute the remaining rules.

If a tool encounters an error outside of the evaluation of a rule, the tool might report
the error to the log and halt. (The tool might also just exit, either normally or abnormally.)
~

If the `kind` property is not present, it shall be considered equivalent to the value `warning`.

### `fullMessage` property { #result-fullMessage }

A `result` object shall contain a property named `fullMessage` whose value is a string that describes the result.

The `fullMessage` property should provide sufficient details to allow an end user to resolve any problem that the result might indicate.
In particular, `fullMessage` shall include all of the following information that is available and relevant to the result:

*	Information sufficient to identify the analysis target, and the location within the target where the problem occurred.

*	The condition within the analysis target that led to the problem being reported.

*	The risks potentially associated with not fixing the problem.

*	The full range of responses to the problem that the end user could take
(including the definition of conditions where it might be appropriate not to fix the problem, or to conclude that the result is a false positive).

The first sentence of the `fullMessage` property should provide a useful summary of the result,
suitable for display in cases where UI is limited.
Tools that construct `fullMessage` in this way need not provide a value for the `shortMessage` property.
Tools that do not construct `fullMessage` in this way should provide a value for the `shortMessage` property,
because otherwise, the initial portion of `fullMessage` that a viewer displays where UI space is limited
might not be understandable.

~ IsoExample
This is an example of a `fullMessage`:
```
    "Deleting object members may compromise performance when subsequently accessing the object.
    Consider setting object member 'x' to null instead, unless this object is a dictionary
    or if runtime semantics otherwise dictate that the existence of a null member is distinct
    from one that is not present at all. This violation can also be ignored for infrequently
    called code paths."
```
~

### `shortMessage` property

A `result` object may contain a property named `shortMessage` whose value is a string that describes the result.
The `shortMessage` property should be a single sentence that is understandable
when displayed in user interface contexts where the available space is limited to a single line of text.

~ IsoExample
This is an example of a `shortMessage`:
```
    "Deleting member 'x' of variable 'y' may compromise performance on subsequent accesses
    of 'y'."
```
~

### `locations` property { #result-locations }

A `result` object shall contain a property named `locations` whose value is an array,
each of whose elements is a `location` object (&sect;[#location]) which specifies a location where the result occurred.
The `locations` array shall contain at least one element if the result can be associated with a location.
In rare circumstances, it might not be possible to specify a location for a result.

~ IsoNumberedExample { @IsoNumberedExample=1}
If a C++ analyzer detects that no file defines a `main` method,
then the result cannot be associated with a file.
~

The `locations` array shall not contain more than one element unless the problem indicated by the result, if any, can only be corrected
by making a change at all of the locations specified by the array elements.

~ IsoNumberedExample
In programming languages that support partial classes,
the name of a single class may occur more than once in the source code.
If a static analysis tool reported that the name of such a class did not conform to a specified convention,
then the resulting log file should contain a single result object,
which should contain a locations array each of whose elements specifies the location in the source code
where the class name occurs.
~

The `locations` array shall not be used to specify distinct occurrences of the same result,
which can be corrected independently.

~ IsoNumberedExample
Consider a static analysis tool which locates misspelled words in documentation,
and suppose this tool scans a document in which the same word is misspelled in two distinct locations.
Then the resulting log file should contain two distinct `result` objects,
each of which should contain a `locations` array containing a single `location` object
specifying the location of one instance of the misspelled word.

In contrast, consider a tool which locates misspelled words in variable names.
If the tool detects a misspelled variable name, it should produce a single `result` object whose
`locations` array contains the location of every reference to the variable,
since fixing some but not all of the references would cause a compilation error.
~

### `toolFingerprint` property { #result-toolFingerprint }

A `result` object may contain a property named `toolFingerprint` whose value is a string
that contributes to the process of uniquely identifying the result.
[Annex A](#Annex-A) explains how a result management system can use this value.

### `executionFlows` property { #result-executionFlows }

A `result` object may contain a property named `executionFlows` whose value is an array of arrays of
`annotatedCodeLocation` objects (&sect;[#annotatedCodeLocation]).
For convenience, in this context we refer to an array of `annotatedCodeLocation` objects as an `executionFlow` object;
hence we may say that the value of the `executionFlows` property is an array of `executionFlow` objects.
The `executionFlows` property is intended for use by static analysis tools that perform flow analysis
in the process of producing results.

Each `executionFlow` object in the `executionFlows` array shall describe a single execution flow.
An execution flow is a sequence of locations visited by the tool in the course of performing a flow analysis.
An execution flow is in turn represented by an array of `annotatedCodeLocation` objects.
This array need not include every location visited by the tool,
but the entries that are present shall occur in the order that the tool visited them.

A single result may contain one or more execution flows, one or more call stacks (&sect;[#result-callStacks]), or both.

~ IsoNote
The SARIF file format allows multiple execution flows within a single `result` object
to allow for the possibility that a static analysis tool might simulate more than one execution flow
in the course of producing a single result.
~

### `stacks` property { #result-callStacks }

A `result` object may contain a property named `stacks` whose value is an array of arrays of
`annotatedCodeLocation` objects (&sect;[#annotatedCodeLocation]).
For convenience, in this context we refer to an array of `annotatedCodeLocation` objects as a `stack` object;
hence we may say that the value of the `stacks` property is an array of `stack` objects.
The `stacks` property is intended for use by static analysis tools that collects call stack information 
in the process of producing results.

Each `stack` object in the stacks array shall describe a single call stack.
A call stack is a sequence of nested function calls simulated by the tool in the course of performing a flow analysis.
A stack is in turn represented by an array of `annotatedCodeLocation` objects.
This array shall include every function call in the stack for which the tool has information,
and the entries that are present shall occur in order with the innermost call first and the outermost call last.

A single result may contain one or more call stacks, one or more execution flows (&sect;[#result-executionFlows]), or both.

~ IsoNumberedNote { @IsoNumberedNote=1}
The SARIF file format allows multiple call stacks within a single `result` object
to allow for the possibility that a static analysis tool might simulate more than one call stack
in the course of producing a single result.
~

~ IsoNumberedNote
It is possible that the static analysis tool will not have location information for every call in the call stack.
This might happen, for example, if application code for which location information is available calls into operating system code
for which location information is not available, which in turn calls back into application code.
~

### `relatedLocations` property { #result-relatedLocations }

A `result` object may contain a property named `relatedLocations` whose value is an array
of one or more `annotatedCodeLocation` objects (&sect;[#annotatedCodeLocation]),
each of which represents a location relevant to understanding the result.

~ IsoExample
Suppose that a tool for analyzing JavaScript has a rule that reports a problem
when a variable declared in an inner scope hides a variable with the same name in an enclosing scope.
The tool would report the problem on the line where the inner variable is declared.
The tool could choose to add an element to the `relatedLocations` array, specifying
the location where the outer variable was declared.

The result might appear in the log file like this:

```
results: [
    {
        "ruleId": "JS3056",
        "kind": "error",
        "shortMessage": "Name 'index' cannot be used in this scope because it would give a different meaning to 'index'.",

        "locations": [
            {
                "analysisTarget": [
                    {
                        "uri": "file:///C:/Code/a.js",
                        "mimeType": "text/javascript",
                        "region": {
                            "startLine": "6",
                            "startColumn": "10"
                        }
                    }
                ]
            }
        ],

        "relatedLocations": [           # An array of annotatedCodeLocation objects (see \(&sect;[#annotatedCodeLocation]\))
            { 
                "message": "The previous declaration of 'index' was here.",
                "physicalLocations": [
                    [
                        {
                            "uri": "file:///C:/Code/a.js",
                            "mimeType": "text/javascript",
                            "region": {
                                "startLine": "2",
                                "startColumn": "6"
                            }
                        }
                    ]
                ]
            }
        ]
    },
    ...
]
```

The tool might write messages to the console like this:

```
C:\Code\a.js(6,10-10) : error : JS3056: Name 'index' cannot be used in this scope because it would give a different meaning to 'index'.
C:\Code\a.js(2,6-6) : info : JS3056: The previous declaration of 'index' was here.
```

~

### `isSuppressedInSource` property { #result-isSuppressedInSource }

A `result` object may contain a property named `isSuppressedInSource` whose value is one of the strings
`"true"` or `"false"`.

Some programming languages offer a syntactic construct for suppressing compiler warnings.
For tools that examine source code written in such a language, this value shall be set to `"true"`
if the tool determines that the result occurred at a location within the scope of an instance of such a construct
which is intended to suppress that particular class of result.
It shall be set to `"false"` if the tool determines that the result did not occur at such a location.
It shall omitted if the tool cannot or chooses not to determine whether the result occurred at such a location.

For tools that do not examine source code written in such a language, this value shall be omitted.

~ IsoExample
The `#pragma` warning construct in C# is such a syntactic construct.
~

### `fixes` property { #result-fixes }

A `result` object may contain a property names `fixes`, whose value is a JSON array of zero or more `fix` objects (&sect;[#fix]).

### `tags` property { #result-tags }

A `result` object may contain a property named `tags`, whose value is a tag set.

### `properties` property { #result-properties }

A `result` object may contain a property named `properties`, whose value is property bag.
This allows tools to include information about the result that is not explicitly specified in the SARIF format.

## `location` object { #location }

### General { #location-General }

A `location` object specifies the location where a static analysis tool produced a result.
A `location` object shall specify the physical location (&sect;[#physicalLocation-info]) of the result,
and it may also specify the logical location (&sect;[#logicalLocation-info]) of the result.

### Physical locations and the `physicalLocation` array { #physicalLocation-info }

A physical location specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.
A physical location is represented by an array of `physicalLocationComponent objects` (&sect;[#physicalLocationComponent]);
for convenience, we refer to this array as a `physicalLocation` object.
This allows reference to results which occur in files nested within other files, for example, within a compressed container.
If the result occurred in such a nested file, the first `physicalLocationComponent` object in the array shall refer to the outermost container,
the next element shall refer to a file nested immediately within that container, and so on,
with the last element referring to the most deeply nested file.

Physical locations are applicable to results that occur in all kinds of programming artifacts.

### Logical locations and the `logicalLocation` array { #logicalLocation-info }

A logical location specifies a reference to a logical construct, for example, a class name or a function name,
without specifying the programming artifact within which that construct occurs.
A logical location is represented by an array of `logicalLocationComponent` objects (&sect;[#logicalLocationComponent]);
for convenience, we refer to this array as a `logicalLocation` object.
This allows reference to results which occur in nested logical components, for example,
a method nested within a class which is in turn nested within a namespace.
If the result occurred in such a nested construct, the first `logicalLocationComponent` object in the array shall refer to
the outermost construct,
the next element shall refer to a construct nested immediately within the first construct,
and so on, with the last element referring to the most deeply nested construct.

### Constraints { #location-Constraints }

Depending on the information available to the tool that produces the SARIF log file,
either or both of the `analysisTarget` property (&sect;[#location-analysisTarget]) and the
`resultFile` property (&sect;[#location-resultFile]) shall be present.

If the tool that produces the log file knows the analysis target, then the `analysisTarget`
property shall be present.
If the tool knows that the result file is different from the analysis target,
then the `resultFile` property shall be present;
otherwise the `resultFile` property shall be absent.

~ IsoNote
Generally, an analysis tool will know both the file it was instructed to scan
(the analysis target) and the file in which it detects a problem (the result file).
~

~ IsoNumberedExample { @IsoNumberedExample=1 }
Suppose a static analysis tool for C++ source code is instructed to scan the source file _a.cpp_,
and suppose the tool detects a problem in _a.cpp_.
In this case, the tool should set the `analysisTarget` property to `a.cpp`,
and it should not set the `resultFile` property.
~

~ IsoNumberedExample
Suppose a static analysis tool for C++ source code is instructed to scan the source file _a.cpp_,
which includes the header file _b.h_,
and suppose the tool detects a problem in _b.h_.
In this case, the tool should set the `analysisTarget` property to `a.cpp`,
and it should set the `resultFile` property to `b.h`.
~

~ IsoNumberedExample
Suppose a static analysis tool for object code detects a problem in the binary file _c.dll_,
and suppose the tool has available symbol information which maps that location within the binary
to a specific line in a source file _d.cpp_.
In this case, the tool should set the `analysisTarget` property to `c.dll`,
and it should set the `resultFile` property to `d.cpp`.
~

If the tool that produces the log file does not know the analysis target,
then the `resultFile` property shall be present and the `analysisTarget` property shall be absent.

~ IsoNote
Some static analysis tools produce output in a format that does not include both the
analysis target and the result file.
In such cases, a conversion tool which translates the output into the SARIF format
might only have the result file available. 
~

~ IsoExample
Suppose a static analysis tool for C++ source code is instructed to scan the source file _a.cpp_,
which includes the header file _b.h_,
and suppose the tool detects a problem in _b.h_.
Suppose further that the tool produces output in a format other than SARIF, for example:

```
{ "file": "b.h", "line": 6, "column" 1, "Uninitialized variable" }
```

Suppose a conversion tool attempts to translate this output into SARIF format.
Suppose that the conversion tool does not know whether the analysis tool was instructed
to scan a source file that included _b.h_, or whether it was instructed to scan _b.h_ directly.
In this case, the conversion tool only knows that the problem occurred in _b.h_.
The conversion tool should set the `resultFile` property to `b.h`,
and it should not set the `analysisTarget` property. 
~

Within any one location object, the `logicalLocation` property (&sect;[#location-logicalLocation])
and the `fullyQualifiedLogicalName` property (&sect;[#location-fullyQualifiedLogicalName])
shall either both be present or both be absent.

### `analysisTarget` property { #location-analysisTarget }

A `location` object may contain a property named `analysisTarget` whose value is a `physicalLocation` object (&sect;[#physicalLocation-info])
that identifies the file that the static analysis tool was instructed to scan.
This need not be the same as the file where the result actually occurred. See `resultFile` (&sect;[#location-resultFile]) for more information on this point.

Whether `analysisTarget` is present depends on the information available to the tool that produces the log file
(see &sect;[#location-Constraints]).

### `resultFile` property { #location-resultFile }

A `location` object may contain a property named `resultFile` whose value is a `physicalLocation` object (&sect;[#physicalLocation-info])
that identifies the file where the static analysis tool produced the result.

Whether `resultFile` is present depends on the information available to the tool that produces the log file
(see &sect;[#location-Constraints]).

### `logicalLocation` property { #location-logicalLocation }

A `location` object may contain a property named `logicalLocation` whose value is a `logicalLocation` object (&sect;[#logicalLocation-info])
which specifies the logical location where the static analysis tool produced the result.

### `fullyQualifiedLogicalName` property { #location-fullyQualifiedLogicalName }

A `location` object may contain a property named `fullyQualifiedLogicalName` whose value is a string
which summarizes the information in the `logicalLocationComponent` array (&sect;[#logicalLocationComponent])
in a format consistent with the programming language in which the programming constructs specified by that array were expressed.

~ IsoNumberedExample { @IsoNumberedExample=1 }
C: `create_process`
~
~ IsoNumberedExample
C++: `Namespace::Class::Method(int, double) const &&`
~
~ IsoNumberedExample
C#: `Namespace1.Namespace2.Class.Method(System.String, int[])`
~

~ IsoNote
The intent of this property is to allow a result log viewer to display the logical location
in a way that is easily understood by an end user.
~

### `tags` property { #location-tags }

A `location` object may contain a property named `tags`, whose value is a tag set.

### `properties` property { #location-properties }

A `location` object may contain a property named `properties`, whose value is a property bag.
This allows tools to include information about the location that is not explicitly specified in the SARIF format.

## `physicalLocationComponent` object { #physicalLocationComponent }

### General { #physicalLocationComponent-General }

A `physicalLocationComponent` object is an element of a `physicalLocation` object (&sect;[#physicalLocation-info]).

### `uri` property { #physicalLocationComponent-uri }

A `physicalLocationComponent` object shall contain a property named `uri` whose value is a string that represents
the location of the file to be modified as a valid URI.

### `mimeType` property { #physicalLocationComponent-mimeType }

A `physicalLocationComponent` object should contain a property named `mimeType` with a string value that specifies
the MIME content-type (RFC 2045) of the file.

### `region` property { #physicalLocationComponent-region }

A `physicalLocationComponent` object may have a property named `region` whose value is a `region` object (&sect;[#region]),
that represents the region within a file where the result occurred.
It should be present only on the last element of the physical location array in which the `physicalLocationComponent` occurs.
This is because all the other elements of the array represent layers of packaging;
only the last element represents the actual file within which the result occurred.

## `region` object { #region }

### General { #region-General }

A `region` object represents a region, that is, a contiguous portion of a file.
The region can occur in a text file or a binary file. 
Every property in a `region` object shall be represented by a non-negative integer,
that is, by a JSON number value with no sign, no fractional part, and no exponent part.

The line number of the first line in a text file is defined to be 1.
The column number of the first column on each line in a text file is defined to be 1.

The offset of the first byte in a binary file is defined to be 0.

### Regions in text files

When the `physicalLocationComponent` object (&sect;[#physicalLocationComponent]) in which a `region` object occurs
represents a text file,
the `region` object represents a span that consists of a contiguous range of zero or more characters within that file.
In that case, the `byteOffset` property (&sect;[#region-byteOffset]) shall not be present.

The start of a region in a text file shall be represented in one of the following ways:

*	By a combination of the `startLine` (&sect;[#region-startLine]) and `startColumn` (&sect;[#region-startColumn]) properties.
    If `startColumn` is not specified, the region is assumed to start at column 1.

    For the remainder of this section, whenever `startColumn` is mentioned, it includes the case where `startColumn` was omitted
    and so is assumed to be 1.

*	By means of the `charOffset` property (&sect;[#region-charOffset]),
which denotes the offset in characters from the start of the file.

The end of a region in a text file need not be specified.
If it is not specified, the length of the region is assumed to be 0.
If it is specified, it shall be represented as follows:

*	If the start of the region was specified by the `startLine` (&sect;[#region-startLine]) and `startColumn` (&sect;[#region-startColumn]) properties,
the end of the region shall be specified by either the `length` property (&sect;[#region-length]),
or by a combination of the `endLine` (&sect;[#region-endLine]) and `endColumn` (&sect;[#region-endColumn]) properties.
If `length` is specified, it shall be non-negative and shall represent a count of characters.

    If `endLine` is not specified, it shall be assumed to be the same as `startLine`.
    
    For the remainder of this section, whenever `endLine` is mentioned, it includes the case where `endLine` was omitted
    and so is assumed to be the same as `startLine`.

    If `endLine` is the same as `startLine`, and if `endColumn` is not specified,
    then `endColumn` shall be assumed to be the same as `startColumn`.

    If `endLine` is different from `startLine`, and `endColumn` is not specified, `endColumn` shall be assumed to be 1.

    For the remainder of this section, whenever `endColumn` is mentioned, it includes the case where
    `endColumn` was omitted and so has its default value, which depends on the value of `endLine`
    as described above.
    
    If `startLine` is the same as `endLine` and `startColumn` is the same as `endColumn`,
    the length of the region is defined to be 0.

*	If the start of the region was specified by the `charOffset` property (&sect;[#region-charOffset]),
the end of the region shall be specified by the `length` property, which denotes a count of characters.

`endLine` shall be greater than or equal to `startLine`.

If `endLine` is equal to `startLine`, then `endColumn` shall be greater than or equal to `startColumn`.

To represent a region that includes the last character in a line,
excluding any trailing newline character,
`endColumn` shall be set to a value 1 greater than the number of characters in the line,
excluding the newline character if present.
This is the case even for the last line of the file, which might not end with a newline.

~ IsoExample
Suppose a text file contains the following line, on line 5:

```
abcde
```

Then the region with `startLine` = 5, `startColumn` = 3, `endLine` = 5, and `endColumn` = 6
represent the three characters `cde`.
This is the case whether or not the line ends with a newline.
~

To include a newline in a region, `endLine` must be greater than `startLine`.

~ IsoExample
Suppose a text file contains the following lines, starting on line 5:

```
abcde
fg
```

Then the region with `startLine` = 5, `startColumn` = 3, `endLine` = 6, and `endColumn` = 1
represent the four characters `cde` plus a newline.
~

### Regions in binary files

When the `physicalLocationComponent` object (&sect;[#physicalLocationComponent]) in which a `region` object occurs
represents a binary file,
the `region` object represents a region that consists of a contiguous range of zero or more bytes within that file.
In that case, the `startLine` (&sect;[#region-startLine]), `startColumn` (&sect;[#region-startColumn]),
`endLine` (&sect;[#region-endLine]), `endColumn` (&sect;[#region-endColumn]), and `charOffset` (&sect;[#region-charOffset])
properties shall not be present.

The start of a region in a binary file shall be represented by the `byteOffset` property (&sect;[#region-byteOffset]),
which denotes the offset in bytes from the start of the file.

The end of a region in a binary file need not be specified.
If it is not specified, the length of the region is assumed to be 0.
If it is specified, it shall be represented by the `length` property (&sect;[#region-length]),
which in this case denotes a count of bytes.

### `startLine` property { #region-startLine }

When a `region` object represents a region in a text file, it may contain a property named `startLine`,
which shall have an integer value equal to the line number of the line containing the first character in the region.

The line number of the first line in a file shall have the value `1`.

When a `region` object represents a region in a binary file, the `startLine` property shall not be present.

### `startColumn` property { #region-startColumn }

When a `region` object represents a region in a text file, it may contain a property named `startColumn`,
which shall have an integer value equal to the column number of the first character in the region.

The column number of the first character in a line shall have the value `1`.

When a `region` object represents a region in a binary file, the `startColumn` property shall not be present.

### `endLine` property { #region-endLine }

When a `region` object represents a region in a text file, and the first and last characters occur on different lines,
and the `length` property (&sect;[#region-length]) is not present,
the `region` object shall contain a property named `endLine`, whose value shall be the line number of the line containing
the last character in the region. If the `length` property is present, the `endColumn` property shall not be present.

When a region object represents a region in a text file, and the first and last characters in the region occur on the same line,
the `endLine` property shall not be present.

When a `region` object represents a region in a binary file, the `endLine` property shall not be present.

### `endColumn` property { #region-endColumn }

When a `region` object represents a region in a text file, it may contain a property named `endColumn`.
If the region has a length of 0, then `endColumn` shall not be present.
If the region has a length greater than 0, then `endColumn` shall be present
(even if its value is the same as the value of `startColumn`,
which could happen if the first and last characters in the range are on different lines),
and its value shall be the column number of the last character of the region.

When a `region` object represents a region in a binary file, the `endColumn` property shall not be present.

### `charOffset` property { #region-charOffset }

When a `region` object represents a region in a text file, it may contain a property named `charOffset`,
which shall have a non-negative integer value equal to the offset (measured in characters) of the first character in the region
from the beginning of the file.

The offset of the first character in a file shall have the value 0.

When a `region` object represents a region in a binary file, the `charOffset` property shall not be present.

### `byteOffset` property { #region-byteOffset}

When a `region` object represents a region in a binary file, it shall contain a property named `byteOffset`,
which shall have an integer value equal to the byte offset of the first character in the region
from the beginning of the file.

The offset of the first byte in a file shall have the value 0.

When a `region` object represents a region in a text file, the `byteOffset` property shall not be present.

### `length` property { #region-length }

A `region` object may have a property called `length`, whose value is an integer.

When the `region` object represents a region in a text file, the value of the `length` property shall be
the number of characters in the region.

When the `region` object represents a region in a binary file, the value of the `length` property shall be
the number of bytes in the region.

If the length of the region (measured in characters for a text file, or bytes for a binary file) is 0,
the `length` property shall not be present.

## `logicalLocationComponent` object { #logicalLocationComponent }

### General { #logicalLocationComponent-General }

A `logicalLocationComponent` object is an element of a `logicalLocation` object (&sect;[#logicalLocation-info])

### `name` property { #logicalLocationComponent-name }

A `logicalLocationComponent` object shall contain a property called `name`, whose value shall be a string that identifies
the construct in which the result occurred.
For example, this property might contain the name of a class or a method.

The name property need not be suitable for display.

~ IsoExample
A C++ analysis tool might emit the `name` property of a function as the "decorated" function name,
which encodes the function signature in a manner that is compiler-dependent and not easily readable.
~

### `kind` property { #logicalLocationComponent-kind }

A `logicalLocationComponent` object should contain a property called `kind`, whose value shall be one of the following strings,
if any of those strings accurately describes the construct identified by this object:

*	`method`
*	`module`
*	`namespace`
*	`package`
*	`resource`
*	`type`

If none of those strings accurately describes the construct, `kind` may contain any value specified by the analysis tool.

## `annotatedCodeLocation` object { #annotatedCodeLocation }

### General { #annotatedCodeLocation-General }

An `annotatedCodeLocation` object is an element of an `executionFlow` object (&sect;[#result-executionFlows]),
a `stack` object (&sect;[#result-callStacks]),
or the `relatedLocations` array (&sect;[#result-relatedLocations]).

### `physicalLocation` property { #annotatedCodeLocation-physicalLocation }

An `annotatedCodeLocation` object must contain a property named `physicalLocation` whose value is a `physicalLocation` object
(&sect;[#physicalLocation-info]) that specifies the code location to which the `annotatedCodeLocation` object refers.

### `message` property { #annotatedCodeLocation-message }

An `annotatedCodeLocation` object may contain a property named `message` whose value is a string that describes
the significance of this entry within the overall execution flow.
For example, if the `annotatedCodeLocation` refers to an `if` statement, the `message` property might contain the string "take true branch".

### `tags` property { #annotatedCodeLocation-tags }

A `annotatedCodeLocation` object may contain a property named `tags`, whose value is a tag set.

### `properties` property { #annotatedCodeLocation-properties }

An `annotatedCodeLocation` object may contain a property named `properties`, whose value is a property bag.
This allows tools to include information about the entry that is not explicitly specified in the SARIF format.

## `fix` object { #fix }

### General { #fix-General }

A `fix` object represents a proposed fix for the problem indicated by the `result` object (&sect;[#result]) in which it occurs.
It specifies a set of files to modify.
For each file, it specifies which bytes to remove, and provides new bytes to be inserted.

~IsoExample

````
    {                                                     # a result object (see \(&sect;[#result]\))
        "fix":
        {
            "description":                                # see \(&sect;[#fix-description]\)
                "Private member names begin with '_'",
            "fileChanges":                                # see \(&sect;[#fix-fileChanges]\)
            [
                {                                         # a fileChange object (see \(&sect;[#fileChange]\))
                    ...
                }
            ]
        }
    }
````

~

### `description` property { #fix-description }

A `fix` object may contain a property named `description` whose value is a string describing the proposed fix.

~IsoNote
The purpose of the `description` property is to enable a result log viewer to present the proposed fix to the end user.
~

~IsoExample
`"Combine declaration and initialization of variable x"`
~

### `fileChanges` property { #fix-fileChanges }

A `fix` object shall contain a property named `fileChanges` whose value is a JSON array of
`fileChange` objects (&sect;[#fileChange]).
The array shall contain at least one element.

~IsoNote
A `fix` object that does not change any files is not meaningful.
~

## `fileChange` object { #fileChange }

### General { #fileChange-General }

A `fileChange` object represents a change to a single file.

~IsoExample

````
    {                                      # a fix object (see \(&sect;[#fix]\))
        "fileChanges":                     # see \(&sect;[#fix-fileChanges]\)
        [
            {                              # a fileChange object
                "uri": "a.h",              # see \(&sect;[#fileChange-uri]\)
                "replacements":            # see \(&sect;[#fileChange-replacements]\)
                [
                    {                      # a replacement object (see \(&sect;[#replacement]\))
                        ...
                    },
                    {                      # another replacement object.
                        ...
                    }
                ]
            }
        ]
    }

````

~

### `uri` property { #fileChange-uri }

A `fileChange` object shall contain a property named `uri` whose value is a string value that represents
the location of the file as a valid URI.

### `replacements` property { #fileChange-replacements }

A `fileChange` object shall contain a property named `replacements` whose value is a JSON array of
`replacement` objects (&sect;[#replacement]),
each of which represents the replacement of a single range of bytes in the file specified by the
`uri` property (&sect;[#fileChange-uri]).
The array shall contain at least one element.

~IsoNote
A `fileChange` object that does not modify any bytes in the file is not meaningful.
~

## `replacement` object { #replacement }

### General { #replacement-General }

A `replacement` object represents the replacement of a single range of bytes in a file.
It specifies the location within the file where the replacement is to be made,
the number of bytes to remove at that location,
and a sequence of bytes to insert at that location.

If a `replacement` object specifies both the removal of a byte range
by means of the `deletedLength` property (&sect;[#replacement-deletedLength])
and the insertion of a sequence of bytes
by means of the `insertedBytes` property (&sect;[#replacement-insertedBytes]),
then the effect of the replacement shall be as if the removal were performed before the insertion.

If a single `fileChange` object (&sect;[#fileChange]) specifies more than one `replacement`,
then the effect of the replacements shall be as if they were performed
in the order they appear in the `replacements` array (&sect;[#fileChange-replacements]).
The `offset` property (&sect;[#replacement-offset]) of each `replacement` shall specify
an offset in the unmodified file.

~IsoExample

Suppose a `fileChange` object contains a `fileChanges` property whose value is the following
array of two `replacement` objects:

````
    "fileChanges":
    [
        {
            "offset": 12,
            "deletedLength": 5,
            "insertedBytes": "ZXhhbXBsZQ=="   # The string "example"
        },

        {
            "offset": 20,
            "deletedLength": 3
        }
    ]
````

The first `replacement` object removes 5 bytes starting at offset 12; that is, it removes bytes 12&ndash;16.
Then it inserts 7 bytes (the UTF-8-encoded string `example`, itself encoded in MIME Base64)
at the same offset.

The second `replacement` object removes 3 bytes starting at offset 20 _with respect to the
unmodified file_. Since 5 bytes were removed and 7 bytes inserted _before_ byte 20, the
3 bytes removed actually start at byte 22.

~

### Constraints { #replacement-Constraints }

In any `replacement` object, either the `deletedLength` property (&sect;[#replacement-deletedLength])
shall be present and have a value greater than 0,
or the `insertedBytes` property (&sect;[#replacement-insertedBytes])
shall be present and have a string value whose length is greater than zero,
or both.

~IsoNote
A `replacement` object in which the `deletedLength` property was absent or had a value of 0,
and in which the `insertedBytes` property was absent or had a value equal to the empty string,
would neither insert nor remove any bytes, and so would not be meaningful.
~

### `offset` property { #replacement-offset }

A `replacement` object shall contain a property named `offset`, whose value shall be a non-negative
integer specifying the offset in bytes from the beginning of the file at which bytes are to be removed,
inserted, or both.
An offset of 0 shall denote the first byte in the file.

### `deletedLength` property { #replacement-deletedLength }

A `replacement` object may contain a property named `deletedLength`, whose value is a
non-negative integer specifying the number of bytes to delete,
starting at the byte offset specified by
the `offset` property (&sect;[#replacement-offset]),
measured from the beginning of the file.

If `deletedLength` is not present, or if its value is 0,
no bytes shall be deleted.

### `insertedBytes` property { #replacement-insertedBytes }

A `replacement` object may contain a property named `insertedBytes`, whose value is a string
that specifies the byte sequence to be inserted at the byte offset specified by
the `offset` property (&sect;[#replacement-offset]),
measured from the beginning of the file.

If `insertedBytes` is not present, or if its value is the empty string,
no bytes shall be inserted.

If the file into which the bytes are to be inserted is a binary file,
the value of the `insertedBytes` string shall be the MIME Base64 encoding
of the byte sequence to be inserted.

If the file into which the bytes are to be inserted is a text file,
the characters to be inserted shall first be encoded in UTF-8.
The value of the `insertedBytes` string shall be the MIME Base64 encoding
of the resulting UTF-8 byte sequence.

* TODO: Relationship between original file encoding, offset, and UTF-8 byte sequence.
* TODO: Explain responsibility of viewer/editor to match encoding.
